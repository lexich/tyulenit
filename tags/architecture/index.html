<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Architecture | ТюленITь</title><meta name=keywords content><meta name=description content><meta name=author content="lexich"><link rel=canonical href=https://tyulenit.com/tags/architecture/><meta name=google-site-verification content="G-00G3WYG3BJ"><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://tyulenit.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tyulenit.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tyulenit.com/favicon-32x32.png><link rel=apple-touch-icon href=https://tyulenit.com/apple-touch-icon.png><link rel=mask-icon href=https://tyulenit.com/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://tyulenit.com/tags/architecture/index.xml><link rel=alternate hreflang=en href=https://tyulenit.com/tags/architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-00G3WYG3BJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-00G3WYG3BJ")}</script><meta property="og:url" content="https://tyulenit.com/tags/architecture/"><meta property="og:site_name" content="ТюленITь"><meta property="og:title" content="Architecture"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://tyulenit.com/seal.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tyulenit.com/seal.jpg"><meta name=twitter:title content="Architecture"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tyulenit.com/ accesskey=h title="ТюленITь (Alt + H)"><img src=https://tyulenit.com/apple-touch-icon.png alt aria-label=logo height=35>ТюленITь</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tyulenit.com/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://tyulenit.com/>Home</a>&nbsp;»&nbsp;<a href=https://tyulenit.com/tags/>Tags</a></div><h1>Architecture
<a href=/tags/architecture/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Writing an Adapter for Fetch API</h2></header><div class=entry-content><p>It seems that there is no such project that does not need to make requests to the server. And it is always a good idea to write a separate abstraction to describe such communication. This not only adds readability and reusability to the code, but also makes it possible to quickly and efficiently write tests for such functionality.
class NetworkService { constructor(private readonly fetch: typeof fetch) {} getUser: (): Promise&lt;IUser> => this.fetch('/api/user').then(d => d.json()) } function getUsername(api: Pick&lt;NetworkService, 'getUser'>) { return api.getUser().then(user => user.name); } test('getUsername', async () => { const name = await getUsername({ getUser: () => Promise.resolve({ name: 'test' } as IUser) }); expect(name).toBe('test'); }); And for an average project, this approach will be sufficient. But sometimes there are requirements that you need to redefine the fetch itself. For example, in our project, we are developing an extension for the browser and we want to make requests through the serviceWorker. And there is a requirement to reimplement the Fetch API. As we know, fetch returns a Response primitive, for the creation of which you need to pass the ReadableStream as the first argument, and the response characteristics as the second. Thus, we can use the following construction.
...</p></div><footer class=entry-footer><span title='2023-06-19 11:06:32 +0400 +0400'>June 19, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;437 words&nbsp;·&nbsp;lexich</footer><a class=entry-link aria-label="post link to Writing an Adapter for Fetch API" href=https://tyulenit.com/en/posts/2023-06-19-fetch/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Написание адаптера для Fetch API</h2></header><div class=entry-content><p>Кажется, что нет такого проекта, в котором не нужно делать запросы к серверу. И всегда хорошей идеей написать отдельную абстракцию для описания подобной коммуникации. Это добавляет коду не только читаемости и переиспользуемости, но и дает возможность быстро и эффективно написать тест для подобной функциональности.
class NetworkService { constructor(private readonly fetch: typeof fetch) {} getUser: (): Promise&lt;IUser> => this.fetch('/api/user').then(d => d.json()) } function getUsername(api: Pick&lt;NetworkService, 'getUser'>) { return api.getUser().then(user => user.name); } test('getUsername', async () => { const name = await getUsername({ getUser: () => Promise.resolve({ name: 'test' } as IUser) }); expect(name).toBe('test'); }); И для среднестатистического проекта такого подхода будет достаточно. Но иногда возникают требования, что нужно переопределить сам fetch. Например, у нас в проекте, мы разрабатываем extension для браузера и хотим делать запросы через serviceWorker. И возникает требования переимплементировать Fetch API. Как мы знаем fetch возвращает примитив Response, для создания которого нужно передать первым аргументом ReadableStream, а вторым характеристики ответа. Таким образом мы можем использовать следующую конструкцию.
...</p></div><footer class=entry-footer><span title='2023-06-19 11:06:32 +0400 +0400'>June 19, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;378 words&nbsp;·&nbsp;lexich</footer><a class=entry-link aria-label="post link to Написание адаптера для Fetch API" href=https://tyulenit.com/ru/posts/2023-06-19-fetch/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>DI в typescript в стиле Java</h2></header><div class=entry-content><p>На работе в проекте столкнулись с достаточно распространенной архитектурной проблемой. Есть набор сервисов, зависящих друг от друга. Первоначально взаимосвязи между сервисами описывались c помощью DI через конструктор.
interface Options { service1: Service1; service2: Service2; serviceN: ServiceN; } class ServiceNew { constructor(private options: Options) {} } В большинстве случаев такой подход является достаточно эффективным. Однако порой возникают ситуации, например, когда 2 сервиса зависят друг от друга и приходится инжектить зависимость через функции-геттеры.
class Sevice1 { constructor( private getService2(): Service2, private serviceN: ServiceN ) {} } class Sevice2 { constructor( private getService1(): Service1, private serviceN: ServiceN ) {} } В ситуации когда таких сервисов например 20, то хочется уже более единообразного подхода. Например мы можем обратиться к опыту языка Java и сохранить все сервисы в один объект и передать ссылку на него в каждый сервис. А для большей изоляции кода можно на уровне типов ограничить список используемых сервисов. Главное условие при таком подходе, что нельзя обращаться к такому объекту в конструкторе, тк в этот момент еще идет наполнение этого объекта. При этом остается декларативность в описании зависимостей и сохраняется единообразность подхода. Также если в каком-то сервисе мы вдруг забудем про объявлении поля ctx, то type-checker об этом напомнит.
...</p></div><footer class=entry-footer><span title='2023-05-31 12:55:03 +0400 +0400'>May 31, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;348 words&nbsp;·&nbsp;lexich</footer><a class=entry-link aria-label="post link to DI в typescript в стиле Java" href=https://tyulenit.com/ru/posts/2023-05-31-injector/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Миграция в React c Context API в Mobx часть 2</h2></header><div class=entry-content><p>В продолжение вчерашней темы, про миграцию на mobx резонно возникает вопрос, а зачем вообще мигрировать на что-то, если есть redux, context api, useReducer и всякие подобные решения на которых строится сейчас React разработка.
export const AppContext = createContext({}); export const AppContextProvider: FC = ({ children }) => { const [user, setUser] = useState&lt;IUser>(undefined); const [profile, setProfile] = useState&lt;IProfile>(undefined); const setUserId = (id: string) => loadUser(id).then(setUser); useEffect(() => { if (user) { loadProfile(user).then(setProfile); } else { setProfile(undefined); } }, [user]); return ( &lt;AppContext.Provider values={{ user, profile, setUserId }}> {children} &lt;/AppContext.Provider>); } const Component: FC = () => { const { profile } = useContext(AppContext); return &lt;div>{profile.content}&lt;/div> } Представим виртуальный пример, который достаточно просто встретить во многих проектах. Что в нем не так? Проведем мысленный эксперимент. У нас есть компонент, который отображает profile. Сколько раз перерендерится наш компонент, когда мы вызовем setUserId. Первый ре-рендер будет на setUser, потом у нас вызовется useEffect. Его бы я вообще примерно никогда не использовал для работы со стейтом. Далее setProfile и это уже второй ререндер. Такое же поведение будет в каждом компоненте, использующим этот контекст. И неоптимальность - это полбеды, но если, например, мы хотим небольшой тест, чтобы проверить, как это все работает… я даже думать об этом не хочу и перехожу в лагерь тех кто не пишет тесты и рассуждают о них только на собеседовании.
...</p></div><footer class=entry-footer><span title='2023-05-12 12:49:23 +0400 +0400'>May 12, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;383 words&nbsp;·&nbsp;lexich</footer><a class=entry-link aria-label="post link to Миграция в React c Context API в Mobx часть 2" href=https://tyulenit.com/ru/posts/2023-05-12-migration-reason/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Миграция в React c Context API в Mobx часть 1</h2></header><div class=entry-content><p>В жизни можно бесконечно делать 3 вещи, смотреть как горит огонь, как течет вода и как я пытаюсь агитировать переписать react приложение с Context API на что-то более функциональное, на чем можно построить нормальную архитектуру приложения. Последнее время я все чаще выбираю mobx, поэтому поговорим сегодня про него.
Так что же делать, если приложение уже написано, а с чего-то начать надо?
Предположим, у нас есть компонент, который обращается к глобальному стейту приложения.
...</p></div><footer class=entry-footer><span title='2023-05-11 12:47:31 +0400 +0400'>May 11, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;357 words&nbsp;·&nbsp;lexich</footer><a class=entry-link aria-label="post link to Миграция в React c Context API в Mobx часть 1" href=https://tyulenit.com/ru/posts/2023-05-11-contextapimigration/></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://tyulenit.com/>ТюленITь</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>